feat: Add comprehensive import/module system with natural English syntax

Implemented Task 14: Complete module system for code organization with natural
English-style syntax using 'bring' and 'share' keywords. The system supports
selective imports, aliasing, standard library modules, nested imports, and
proper context preservation for imported functions.

FEATURES ADDED:

Import Syntax:
- Full module import: "bring in module"
- Selective import: "bring item from module"
- Aliased import: "bring item as alias from module"
- Multiple imports: "bring item1, item2 from module"
- Subdirectory support: "bring item from subdir/module"

Export Syntax:
- Explicit exports: "share item1, item2"
- Implicit exports: All non-underscore top-level definitions exported by default
- Private symbols: Use underscore prefix (_private_func) to prevent auto-export

Standard Library:
- math.uttr: Mathematical operations (PI, E, abs, pow, sqrt, max, min, round, floor, ceil)
- lists.uttr: List utilities (range, sum, max_list, min_list, reverse, contains)
- strings.uttr: String operations (starts_with, ends_with, trim, count_occurrences, repeat, capitalize)

Module System Architecture:
- Module caching: Modules executed once and cached for subsequent imports
- Circular import detection: Prevents infinite import loops
- Search paths: Current directory → Working directory → stdlib/
- Path resolution: Supports forward slashes for subdirectories
- Error handling: ModuleNotFoundError, CircularImportError

NEW FILES CREATED:

Core Module System:
- module_loader.py: Module finding, loading, and caching with circular import detection
- module.py: Module representation with symbol tables and export management
- module_config.py: Module search path configuration

AST Nodes:
- nodes/import_node.py: AST node for import statements (bring)
- nodes/share_node.py: AST node for export declarations (share)

Error Classes:
- errors/module_not_found_error.py: Module not found error
- errors/circular_import_error.py: Circular dependency error

Standard Library:
- stdlib/math.uttr: Mathematical functions and constants
- stdlib/lists.uttr: List manipulation utilities
- stdlib/strings.uttr: String processing functions

Examples:
- examples/modules/calculator.uttr: Reusable calculator library
- examples/modules/use_calculator.uttr: Calculator usage example
- examples/modules/validation.uttr: Input validation utilities
- examples/modules/stdlib_demo.uttr: Standard library demonstration
- examples/modules/README.md: Module examples documentation

Test Suite (8 files, 43+ tests):
- tests/test_imports.uttr: Basic import system tests (10 tests)
- tests/test_imports_advanced.uttr: Advanced import tests with subdirectories (8 tests)
- tests/test_import_scope.uttr: Import scope and context preservation test
- tests/test_nested_import.uttr: Nested module import test
- tests/test_nested_import2.uttr: Indirect module import test
- tests/test_paths.uttr: Module path resolution tests (3 tests)
- tests/test_module_a.uttr: Test module A
- tests/test_module_b.uttr: Test module B

Supporting Test Modules:
- tests/modules/helpers.uttr: Helper utilities in subdirectory
- tests/modules/subdir/deep_module.uttr: Deep nested module
- tests/modules/subdir/sibling_module.uttr: Sibling module for testing
- tests/modules/subdir/import_sibling.uttr: Module that imports from sibling

Documentation:
- docs/import_context_fix.md: Technical documentation of context preservation fix
- tests/README.md: Updated with module system test coverage
- examples/modules/README.md: Complete module examples guide

FILES MODIFIED:

Lexer & Parser:
- tokens.py: Added 'bring' and 'share' keywords to token types
- constants.py: Added underscore to LETTERS for identifiers like _private_func
- parser.py: Added import_expr(), share_expr(), parse_module_path() methods
  * parse_module_path(): Handles module paths with forward slashes
  * statement(): Updated to check for 'bring' and 'share' keywords
- lexer.py: Fixed make_greater_than_or_rangle() to properly distinguish GT from RANGLE tokens

Interpreter:
- interpreter.py: Added visit_ImportNode() and visit_ShareNode() methods
  * Module loading and execution with isolated contexts
  * Symbol importing with selective/aliased support
  * Function context preservation fix (lines 95-107)
- entry.py: Sets context.display_name for proper relative import resolution

Documentation:
- README.md: Added Module System section with syntax, examples, and technical notes
  * Updated features list to include module system
  * Marked Task 14 as completed
  * Added module system to test suite description

BUG FIXES:

Context Preservation for Imported Functions:
Fixed critical bug where functions imported from modules lost access to their
module-level imports when called from external contexts.

Issue: When a function was accessed via VarAccessNode, it was copied and its
context was overwritten with the current context, causing the function to lose
access to symbols in its defining module.

Solution: Modified visit_VarAccessNode() in interpreter.py to preserve the
original context for user-defined functions while allowing builtin functions
to use the current context. This enables proper symbol resolution through the
function's original module scope.

Before: All functions had their context replaced on variable access
After: User-defined functions preserve defining context, builtins use current context

Lexer Token Fix:
Fixed make_greater_than_or_rangle() to properly distinguish between:
- GT token (>) for comparisons
- RANGLE token (>) for tuple closing

The fix checks the last token type and next character to determine the correct
token type, preventing parser errors in tuple and comparison contexts.

TECHNICAL DETAILS:

Module Loading Process:
1. Module path resolution through search paths
2. Circular import detection via loading stack
3. Module parsing and AST generation
4. Execution in isolated context with global symbol table as parent
5. Symbol export collection (explicit or implicit)
6. Module caching for reuse

Function Context Preservation:
- Functions capture their defining context via .set_context(context)
- When imported, functions retain original context to access module symbols
- Function execution creates new context with defining context as parent
- Symbol lookup traverses parent symbol table chain

Import Resolution:
1. Parse module path (handle subdirectories with /)
2. Find module file in search paths
3. Check cache for already-loaded module
4. Load and execute module if not cached
5. Extract exported symbols
6. Import symbols into current context

TEST COVERAGE:

All 43 tests pass with 100% success rate including:
- Full module imports
- Selective imports
- Aliased imports
- Standard library usage
- Nested imports (modules importing modules)
- Subdirectory imports
- Path resolution
- Error handling (module not found, circular imports, undefined exports)
- Context preservation in nested import scenarios

Import-specific test results: 8/8 tests passed
- test_imports.uttr: ✓ PASS (10 tests)
- test_imports_advanced.uttr: ✓ PASS (8 tests)
- test_import_scope.uttr: ✓ PASS
- test_nested_import.uttr: ✓ PASS
- test_nested_import2.uttr: ✓ PASS
- test_paths.uttr: ✓ PASS (3 tests)
- test_module_a.uttr: ✓ PASS
- test_module_b.uttr: ✓ PASS

BREAKING CHANGES: None

BACKWARD COMPATIBILITY: Fully maintained - all existing tests pass

Co-authored-by: GitHub Copilot
